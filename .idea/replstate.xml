<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1413998207052">{:repl-history {:ide [], :local [&quot;(longest-path-starting-from  [ [ 1 4]  [3 1] [ 2 3]] [1 2])&quot; &quot;(def g [[1 2] [3 4] [ 1 3] [3 1] [2 3]])&quot; &quot;(map (partial longest-path-starting-from g) g)&quot; &quot;(filter #(= (first %) (last %) (map (partial longest-path-starting-from g) g)))&quot; &quot;(filter #(= (first %) (last %)) (map (partial longest-path-starting-from g) g))&quot; &quot;(graph-has-cycles g)&quot; &quot;(graph-has-cycles [[1 2] [2 3]])&quot; &quot;(graph-has-cycles [[2 1] [2 3]])&quot; &quot;(graph-has-cycles [[1 2] [2 3] [3 1] [1 4] [1 2]])&quot; &quot;(graph-has-cycles [[1 2] [2 3] [3 1] [1 4] [2 1]])&quot; &quot;(graph-has-cycles [[2 1] [2 3] [3 1] [1 4] [1 2]])&quot; &quot;(graph-has-cycles [[2 1] [2 3] [3 1] [1 2] [1 4]])&quot; &quot;(graph-has-cycles [[2 3] [2 1]  [3 1] [1 2] [1 4]])&quot; &quot;(cluster-connected-edges [[2 3] [2 1]  [3 1] [1 2] [1 4]])&quot; &quot;(find-nexts [[2 1] [2 3] [2 4]] 2)&quot; &quot;(find-nexts [[2 1] [2 3] [2 4]] [1 2])&quot; &quot;(def g (graph [ 1 2] [ 2 3] [3 1]))&quot; &quot;(def g (loom.graph/graph [ 1 2] [ 2 3] [3 1]))&quot; &quot;g&quot; &quot;(bf-pat)&quot; &quot;(def g (loom.graph/digraph [ 1 2] [ 2 3] [3 1]))&quot; &quot;(directed? g)&quot; &quot;(loom.graph/directed? g)&quot; &quot;(loom.alg/bf-path g 1 2)&quot; &quot;(def g (loom.graph/digraph [ 1 2] [ 2 3] [3 4]))&quot; &quot;(loom.alg/bf-path g 1 3)&quot; &quot;(loom.alg/bf-path g 3 1)&quot; &quot;(permutations [1 2 3])&quot; &quot;(permutations [1 2 3] 2)&quot; &quot;(combinations [1 2 3] 2)&quot; &quot;(clojure.math.combinatorics/combinations [1 2 3] 2)&quot; &quot;(apply digraph [[1 2] [2 3] [3 4]])&quot; &quot;(node)&quot; &quot;(loom.graph/nodes (apply digraph [[1 2] [2 3] [3 4]]))&quot; &quot;(vec (loom.graph/nodes (apply digraph [[1 2] [2 3] [3 4]])))&quot; &quot;(combinations (vec (loom.graph/nodes (apply digraph [[1 2] [2 3] [3 4]]))) 2)&quot; &quot;(seq '(1 2))&quot; &quot;(if (seq '(1 2)) 1 2)&quot; &quot;(has-cycles? [[1 2] [2 3] [3 4]])&quot; &quot;(into [] (has-cycles? [[1 2] [2 3] [3 4] [3 1]]))&quot; &quot;(has-cycles? [[1 2] [2 3] [3 4] [3 1]])&quot; &quot;(graph-cycles [[1 2] [2 3] [3 1]])&quot; &quot;(graph-cycles [[1 2] [2 3] [3 4]])&quot; &quot;(graph-cycles [[1 2] [2 3] [3 1] [4 5] [5 3] [3 4]])&quot; &quot;(graph-cycles [[1 2] [2 3]  [4 5] [5 3] [3 4]])&quot; &quot;(graph-cycles [[1 2] [2 3]   [4 5] [5 3] [3 4] [3 2]])&quot; &quot;(every? (partial predecessors-of-task-exist? tasks) tasks )&quot; &quot;(ns milestones.dyna-scheduler-test\n  (:require [milestones.dyna-scheduler :refer :all])\n  (:use expectations))\n\n(def tasks {1 {:task-name \&quot;Bring bread\&quot;\n               :resource-id \&quot;mehdi\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n             2 {:task-name \&quot;Bring butter\&quot;\n              :resource-id \&quot;rafik\&quot;\n              :duration 5\n              :priority 1\n              :predecessors []}\n\n             3 {:task-name \&quot;Put butter on bread\&quot;\n              :resource-id \&quot;salma\&quot;\n              :duration 3\n              :priority 1\n              :predecessors [1 2]}\n\n             4 {:task-name \&quot;Eat toast\&quot;\n                :resource-id \&quot;rafik\&quot;\n                :duration 4\n                :priority 1\n                :predecessors [3]}\n\n             5 {:task-name \&quot;Eat toast\&quot;\n                :resource-id \&quot;salma\&quot;\n                :duration 4\n                :priority 1\n                :predecessors [3]}\n\n                ;; now some milestones\n             6 {:task-name \&quot;Toasts ready\&quot;\n                 :resource-id :milestones\n                 :predecessors [3]\n\n              }\n\n})&quot; &quot;ns&quot; &quot;(def tasks {1 {:task-name \&quot;Bring bread\&quot;\n               :resource-id \&quot;mehdi\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n             2 {:task-name \&quot;Bring butter\&quot;\n              :resource-id \&quot;rafik\&quot;\n              :duration 5\n              :priority 1\n              :predecessors []}\n\n             3 {:task-name \&quot;Put butter on bread\&quot;\n              :resource-id \&quot;salma\&quot;\n              :duration 3\n              :priority 1\n              :predecessors [1 2]}\n\n             4 {:task-name \&quot;Eat toast\&quot;\n                :resource-id \&quot;rafik\&quot;\n                :duration 4\n                :priority 1\n                :predecessors [3]}\n\n             5 {:task-name \&quot;Eat toast\&quot;\n                :resource-id \&quot;salma\&quot;\n                :duration 4\n                :priority 1\n                :predecessors [3]}\n\n                ;; now some milestones\n             6 {:task-name \&quot;Toasts ready\&quot;\n                 :resource-id :milestones\n                 :predecessors [3]\n\n              }\n\n})&quot; &quot;(every? (partial mg/predecessors-of-task-exist? tasks) tasks )&quot; &quot;(some (not (partial mg/predecessors-of-task-exist? tasks)) tasks )&quot; &quot;(filter (not (partial mg/predecessors-of-task-exist? tasks)) tasks )&quot; &quot;(def tasks {1 {:task-name \&quot;Bring bread\&quot;\n               :resource-id \&quot;mehdi\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n             2 {:task-name \&quot;Bring butter\&quot;\n              :resource-id \&quot;rafik\&quot;\n              :duration 5\n              :priority 1\n              :predecessors []}\n\n             3 {:task-name \&quot;Put butter on bread\&quot;\n              :resource-id \&quot;salma\&quot;\n              :duration 3\n              :priority 1\n              :predecessors [1 2]}\n\n             4 {:task-name \&quot;Eat toast\&quot;\n                :resource-id \&quot;rafik\&quot;\n                :duration 4\n                :priority 1\n                :predecessors [3]}\n\n             5 {:task-name \&quot;Eat toast\&quot;\n                :resource-id \&quot;salma\&quot;\n                :duration 4\n                :priority 1\n                :predecessors [3]}\n\n                ;; now some milestones\n             6 {:task-name \&quot;Toasts ready\&quot;\n                 :resource-id :milestones\n                 :predecessors [37]\n\n              }\n\n})&quot; &quot;(def tasks {1 {:task-name \&quot;Bring bread\&quot;\n               :resource-id \&quot;mehdi\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n             2 {:task-name \&quot;Bring butter\&quot;\n              :resource-id \&quot;rafik\&quot;\n              :duration 5\n              :priority 1\n              :predecessors []}\n\n             3 {:task-name \&quot;Put butter on bread\&quot;\n              :resource-id \&quot;salma\&quot;\n              :duration 3\n              :priority 1\n              :predecessors [1 2]}\n\n             4 {:task-name \&quot;Eat toast\&quot;\n                :resource-id \&quot;rafik\&quot;\n                :duration 4\n                :priority 1\n                :predecessors [3]}\n\n             5 {:task-name \&quot;Eat toast\&quot;\n                :resource-id \&quot;salma\&quot;\n                :duration 4\n                :priority 1\n                :predecessors [39989]}\n\n                ;; now some milestones\n             6 {:task-name \&quot;Toasts ready\&quot;\n                 :resource-id :milestones\n                 :predecessors [3]\n\n              }\n\n})&quot; &quot;tasks&quot; &quot;(filter (comp not (partial mg/predecessors-of-task-exist? tasks)) tasks )&quot; &quot;(filter  (partial (comp not mg/predecessors-of-task-exist?) tasks) tasks )&quot; &quot;(predecessors-of-task-exist? tasks {:task-name \&quot;Bring bread\&quot;, :resource-id \&quot;mehdi\&quot;, :duration 5, :priority 1, :predecessors []})&quot; &quot;(predecessors-of-task-exist? tasks {:task-name \&quot;Bring bread\&quot;, :resource-id \&quot;mehdi\&quot;, :duration 5, :priority 1, :predecessors [26]})&quot; &quot;(filter (comp not (partial mg/predecessors-of-task-exist? tasks)) (vals tasks) )&quot; &quot;(filter (comp not (partial mg/predecessors-of-task-exist? tasks) val )  tasks )&quot; &quot;(contains (keys {:a 1 :b 2}) :a )&quot; &quot;(contains? (keys {:a 1 :b 2}) :a )&quot; &quot;(contains? {:a 1 :b 2} :a )&quot; &quot;(contains? {:a 1 :b 2} :c )&quot; &quot;(contains? {:a 1 :b 2} 1 )&quot; &quot;(map (partial contains? {:a 1 :b 2} [:a :b]))\n     &quot; &quot;(map (partial contains? {:a 1 :b 2}) [:a :b])\n     &quot; &quot;(reduce and (map (partial contains? {:a 1 :b 2}) [:a :b]))\n     &quot; &quot;( every? (partial contains? {:a 1 :b 2}) [:a :b])\n     &quot; &quot;( every? (partial contains? {:a 1 :b 2}) [:a :b :c])\n     &quot; &quot;(map #(if ((comp not (partial contains? {:a 1 :b 2})) % ) % nil) [:a :b :c])\n     &quot; &quot;(into [] (map #(if ((comp not (partial contains? {:a 1 :b 2})) % ) % nil) [:a :b :c]))\n     &quot; &quot;(reduce conj [] (map #(if ((comp not (partial contains? {:a 1 :b 2})) % ) % nil) [:a :b :c]))\n     &quot; &quot;(map #(if ((comp not (partial contains? {:a 1 :b 2})) % ) %) [:a :b :c])\n     &quot; &quot;(filter (comp not nil?) (map #(if ((comp not (partial contains? {:a 1 :b 2})) % ) %) [:a :b :c]))\n     &quot; &quot;(missing-prop-for-task {:a 1 :b 2} [:c :b])&quot; &quot;(missing-prop-for-task {:a 1 :b 2} [:b])&quot; &quot;(tasks-w-missing-properties {1 {:a 1 :b 3}\n                            2 {:a 2 :b}} [:c])&quot; &quot;(tasks-w-missing-properties {1 {:a 1 :b 3}\n                            2 {:a 2 :b 2}} [:c])&quot; &quot;(tasks-w-missing-properties {1 {:a 1 :b 3}\n                            2 {:a 2 :b 2}} [:a])&quot; &quot;(missing-prop-for-task {:a 1 :b 2} [:a :c])&quot; &quot;(vec (filter (comp not nil?) (map #(if ((comp not (partial contains? {:a 1 :b 2})) % ) %) [:a :b :c])))\n     &quot; &quot;(vec (filter (comp not nil?) (map #(if ((comp not (partial contains? {:a 1 :b 2 :c 3})) % ) %) [:a :b :c])))\n     &quot; &quot;(missing-prop-for-task {:a 1 :b 2} [:c])&quot; &quot;(missing-prop-for-task {:a 1 :b 2 :c 3} [:c])&quot; &quot;(for [[id t ]{1 {:a 2 :b 2}\n                            \n                            2 {:a 1 :c 3}} :let [y (t :a)] :when (= y 1) ] t )&quot; &quot;(tasks-w-missing-properties {1 {:a 1 :b 2}\n                            \n                            2 {:a 1 :c 3}} \n                            [:b :c]\n                            )&quot; &quot;(empty [])&quot; &quot;(tasks-w-missing-properties {1 {:a 1 :b 2}\n                            \n                            2 {:a 1 :c 3}} \n                            [:b]\n                            )&quot; &quot;(tasks-w-missing-properties {1 {:a 1 :b 2}\n                            \n                            2 {:a 1 :c 3}} \n                            [ :c :b]\n                            )&quot; &quot;(tasks-w-missing-properties {1 {:a 1 :b 2}\n                            \n                            2 {:a 1 :c 3}} \n                            [ :a]\n                            )&quot; &quot;*ns*&quot; &quot;(tasks-w-non-existent-predecessors {1 {:a 1 :predecessors [2]}})&quot; &quot;(tasks-w-non-existent-predecessors {1 {:a 1 :predecessors [1]}})&quot; &quot;(seq ())&quot; &quot;(seq nil)&quot; &quot;{:a nil}&quot; &quot;(verif-tasks {1 {:a 2}\n             2 {:a 1 :predecessors [4]}\n             3 {:a 1 :b 2}\n4 {:a 1 :b 2 :predecessors [2]}\n             })&quot; &quot;(verif-tasks {1 {:a 2}\n             2 {:a 1 :predecessors [4]}\n             3 {:a 1 :b 2}\n4 {:a 1 :b 2 :predecessors [2]}\n             } [:a :b])&quot;], :remote []}}</component>
</project>

