<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1414020347362">{:repl-history {:ide [], :local [&quot;(filter (comp not (partial mg/predecessors-of-task-exist? tasks)) (vals tasks) )&quot; &quot;(filter (comp not (partial mg/predecessors-of-task-exist? tasks) val )  tasks )&quot; &quot;(contains (keys {:a 1 :b 2}) :a )&quot; &quot;(contains? (keys {:a 1 :b 2}) :a )&quot; &quot;(contains? {:a 1 :b 2} :a )&quot; &quot;(contains? {:a 1 :b 2} :c )&quot; &quot;(contains? {:a 1 :b 2} 1 )&quot; &quot;(map (partial contains? {:a 1 :b 2} [:a :b]))\n     &quot; &quot;(map (partial contains? {:a 1 :b 2}) [:a :b])\n     &quot; &quot;(reduce and (map (partial contains? {:a 1 :b 2}) [:a :b]))\n     &quot; &quot;( every? (partial contains? {:a 1 :b 2}) [:a :b])\n     &quot; &quot;( every? (partial contains? {:a 1 :b 2}) [:a :b :c])\n     &quot; &quot;(map #(if ((comp not (partial contains? {:a 1 :b 2})) % ) % nil) [:a :b :c])\n     &quot; &quot;(into [] (map #(if ((comp not (partial contains? {:a 1 :b 2})) % ) % nil) [:a :b :c]))\n     &quot; &quot;(reduce conj [] (map #(if ((comp not (partial contains? {:a 1 :b 2})) % ) % nil) [:a :b :c]))\n     &quot; &quot;(map #(if ((comp not (partial contains? {:a 1 :b 2})) % ) %) [:a :b :c])\n     &quot; &quot;(filter (comp not nil?) (map #(if ((comp not (partial contains? {:a 1 :b 2})) % ) %) [:a :b :c]))\n     &quot; &quot;(missing-prop-for-task {:a 1 :b 2} [:c :b])&quot; &quot;(missing-prop-for-task {:a 1 :b 2} [:b])&quot; &quot;(tasks-w-missing-properties {1 {:a 1 :b 3}\n                            2 {:a 2 :b}} [:c])&quot; &quot;(tasks-w-missing-properties {1 {:a 1 :b 3}\n                            2 {:a 2 :b 2}} [:c])&quot; &quot;(tasks-w-missing-properties {1 {:a 1 :b 3}\n                            2 {:a 2 :b 2}} [:a])&quot; &quot;(missing-prop-for-task {:a 1 :b 2} [:a :c])&quot; &quot;(vec (filter (comp not nil?) (map #(if ((comp not (partial contains? {:a 1 :b 2})) % ) %) [:a :b :c])))\n     &quot; &quot;(vec (filter (comp not nil?) (map #(if ((comp not (partial contains? {:a 1 :b 2 :c 3})) % ) %) [:a :b :c])))\n     &quot; &quot;(missing-prop-for-task {:a 1 :b 2} [:c])&quot; &quot;(missing-prop-for-task {:a 1 :b 2 :c 3} [:c])&quot; &quot;(for [[id t ]{1 {:a 2 :b 2}\n                            \n                            2 {:a 1 :c 3}} :let [y (t :a)] :when (= y 1) ] t )&quot; &quot;(tasks-w-missing-properties {1 {:a 1 :b 2}\n                            \n                            2 {:a 1 :c 3}} \n                            [:b :c]\n                            )&quot; &quot;(empty [])&quot; &quot;(tasks-w-missing-properties {1 {:a 1 :b 2}\n                            \n                            2 {:a 1 :c 3}} \n                            [:b]\n                            )&quot; &quot;(tasks-w-missing-properties {1 {:a 1 :b 2}\n                            \n                            2 {:a 1 :c 3}} \n                            [ :c :b]\n                            )&quot; &quot;(tasks-w-missing-properties {1 {:a 1 :b 2}\n                            \n                            2 {:a 1 :c 3}} \n                            [ :a]\n                            )&quot; &quot;*ns*&quot; &quot;(tasks-w-non-existent-predecessors {1 {:a 1 :predecessors [2]}})&quot; &quot;(tasks-w-non-existent-predecessors {1 {:a 1 :predecessors [1]}})&quot; &quot;(seq ())&quot; &quot;{:a nil}&quot; &quot;(verif-tasks {1 {:a 2}\n             2 {:a 1 :predecessors [4]}\n             3 {:a 1 :b 2}\n4 {:a 1 :b 2 :predecessors [2]}\n             })&quot; &quot;(seq [1])&quot; &quot;(if (seq [1] 1)\n  )&quot; &quot;(if (seq [1]) 1)&quot; &quot;(if (seq []) 1)&quot; &quot;(seq {1 [:b], 2 [:b]})&quot; &quot;(if (seq {1 [:b], 2 [:b]}) 1 2)&quot; &quot;(into {} '(1 2) '(1 2))&quot; &quot;(verif-tasks {1 {:a 2}\n             2 {:a 1 :predecessors [4]}\n             3 {:a 1 :b 2}\n4 {:a 1 :b 2 :predecessors [2]}\n             } [:a :b])&quot; &quot;:a#&quot; &quot;a#&quot; &quot;(gensym a)&quot; &quot;(gensym :a)&quot; &quot;(prepare-milestone {:milestone-name \&quot;toasts\&quot; :predecessors [3]} )&quot; &quot;((prepare-milestone {:milestone-name \&quot;toasts\&quot; :predecessors [3]} ) :resource-id)&quot; &quot;{:is-milestone true} :is-milestone&quot; &quot;({:is-milestone true} :is-milestone)&quot; &quot;({:razerzer true} :is-milestone)&quot; &quot;(def tasks {1 {:task-name \&quot;Bring bread\&quot;\n               :resource-id \&quot;mehdi\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            2 {:task-name \&quot;Bring butter\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            3 {:task-name \&quot;Put butter on bread\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 3\n               :priority 1\n               :predecessors [1 2]}\n\n            4 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 4\n               :priority 1\n               :predecessors [3]}\n\n            5 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 4\n               :priority 1\n               :predecessors [3]}\n\n            ;; now some milestones\n            6 {:milestone-name \&quot;Toasts ready\&quot;\n               :predecessors [3]\n               }\n\n            })&quot; &quot;tasks&quot; &quot;(def tasks {1 {:task-name \&quot;Bring bread\&quot;\n               :resource-id \&quot;mehdi\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            2 {:task-name \&quot;Bring butter\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            3 {:task-name \&quot;Put butter on bread\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 3\n               :priority 1\n               :predecessors [1 2]}\n\n            4 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 4\n               :priority 1\n               :predecessors [3]}\n\n            5 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 4\n               :priority 1\n               :predecessors [3]}\n\n            ;; now some milestones\n            6 {:task-name \&quot;Toasts ready\&quot;\n               :is-milestone \&quot;srerzer\&quot;\n               :predecessors [3]\n               }\n\n            })&quot; &quot;(filter (comp :is-milestone val) tasks )&quot; &quot;(merge {:a 1} [:a 2])&quot; &quot;(seq [])&quot; &quot;(tasks-w-no-predecessors tasks)&quot; &quot;(vals (tasks-w-no-predecessors tasks))&quot; &quot;(keys (tasks-w-no-predecessors tasks))&quot; &quot;(vec (keys (tasks-w-no-predecessors tasks)))&quot; &quot;(tasks-w-no-field tasks :resource-id )&quot; &quot;(tasks-w-no-field tasks :predecessors )&quot; &quot;(errors-on-tasks tasks)&quot; &quot;(errors-on-tasks tasks [:duration ])&quot; &quot;(seq [a])&quot; &quot;(seq [:a])&quot; &quot;(clojure.pprint/pprint (errors-on-tasks tasks [:duration ]))&quot; &quot;(every? nil? {:reordering-errors {}, :tasks-w-no-resources-errors [], :tasks-cycles [], :milestones-w-no-predecessors []})&quot; &quot;(every? (comp nil? seq) {:reordering-errors {}, :tasks-w-no-resources-errors [], :tasks-cycles [], :milestones-w-no-predecessors []})&quot; &quot;(every? (comp nil? seq) (vals {:reordering-errors {}, :tasks-w-no-resources-errors [], :tasks-cycles [], :milestones-w-no-predecessors []}))&quot; &quot;(def tasks {1 {:task-name \&quot;Bring bread\&quot;\n               :resource-id \&quot;mehdi\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            2 {:task-name \&quot;Bring butter\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            3 {:task-name \&quot;Put butter on bread\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 3\n               :priority 1\n               :predecessors [1 2]}\n\n            4 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 4\n               :priority 1\n               :predecessors [3]}\n\n            5 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 4\n               :priority 1\n               }\n\n            ;; now some milestones\n            6 {:task-name \&quot;Toasts ready\&quot;\n               :is-milestone \&quot;srerzer\&quot;\n               :predecessors []\n               }\n\n            })&quot; &quot;(schedule! tasks [:duration])&quot; &quot;(into {:a 1} '([:a 2 ] [:a 3]))&quot; &quot;(def tasks {1 {:task-name \&quot;Bring bread\&quot;\n               :resource-id \&quot;mehdi\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            2 {:task-name \&quot;Bring butter\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            3 {:task-name \&quot;Put butter on bread\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 3\n               :priority 1\n               :predecessors [1 2]}\n\n            4 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 4\n               :priority 1\n               :predecessors [3]}\n\n            5 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 4\n               :priority 1\n               :predecessors [3]}\n\n            ;; now some milestones\n            6 {:task-name \&quot;Toasts ready\&quot;\n               :is-milestone true\n               :predecessors [3]\n               }\n\n            })&quot; &quot;(run-scheduler! (prepare-tasks tasks) [:duration])&quot; &quot;(tasks-w-no-field tasks :resource-id)&quot; &quot;(into {} (tasks-w-no-field tasks :resource-id))&quot; &quot;(seq nil)&quot; &quot;(nil? nil)&quot; &quot;(map (comp nil? seq field :is-milestone val) tasks)&quot; &quot;(map (comp nil? seq  :is-milestone val) tasks)&quot; &quot;(map (comp (not   :is-milestone val)) tasks)&quot; &quot;(filter (comp (not   :is-milestone val)) tasks)&quot; &quot;(filter (comp not   :is-milestone val) tasks)&quot; &quot;(tasks-w-no-field tasks :is-milestone)&quot; &quot;(errors-on-tasks tasks [:duration])&quot; &quot;(scheduler tasks [:duration])&quot; &quot;(schedule tasks [:duration])&quot; &quot;(def result ((schedule tasks [:duration]) :result))&quot; &quot;(prepare-tasks tasks)&quot; &quot;(def curated (prepare-tasks tasks))&quot; &quot;(total-task-duration tasks)&quot; &quot;(map :resource-id (vals curated))&quot; &quot;(into #{} (map :resource-id (vals curated)))&quot; &quot;\n(clojure.pprint/pprint (schedule tasks [:duration]))&quot;], :remote []}}</component>
</project>

