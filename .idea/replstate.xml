<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1414508094637">{:repl-history {:ide [], :local [&quot;(seq {1 [:b], 2 [:b]})&quot; &quot;(if (seq {1 [:b], 2 [:b]}) 1 2)&quot; &quot;(into {} '(1 2) '(1 2))&quot; &quot;(verif-tasks {1 {:a 2}\n             2 {:a 1 :predecessors [4]}\n             3 {:a 1 :b 2}\n4 {:a 1 :b 2 :predecessors [2]}\n             } [:a :b])&quot; &quot;:a#&quot; &quot;a#&quot; &quot;(gensym a)&quot; &quot;(gensym :a)&quot; &quot;(prepare-milestone {:milestone-name \&quot;toasts\&quot; :predecessors [3]} )&quot; &quot;((prepare-milestone {:milestone-name \&quot;toasts\&quot; :predecessors [3]} ) :resource-id)&quot; &quot;{:is-milestone true} :is-milestone&quot; &quot;({:is-milestone true} :is-milestone)&quot; &quot;({:razerzer true} :is-milestone)&quot; &quot;(def tasks {1 {:task-name \&quot;Bring bread\&quot;\n               :resource-id \&quot;mehdi\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            2 {:task-name \&quot;Bring butter\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            3 {:task-name \&quot;Put butter on bread\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 3\n               :priority 1\n               :predecessors [1 2]}\n\n            4 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 4\n               :priority 1\n               :predecessors [3]}\n\n            5 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 4\n               :priority 1\n               :predecessors [3]}\n\n            ;; now some milestones\n            6 {:milestone-name \&quot;Toasts ready\&quot;\n               :predecessors [3]\n               }\n\n            })&quot; &quot;tasks&quot; &quot;(def tasks {1 {:task-name \&quot;Bring bread\&quot;\n               :resource-id \&quot;mehdi\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            2 {:task-name \&quot;Bring butter\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            3 {:task-name \&quot;Put butter on bread\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 3\n               :priority 1\n               :predecessors [1 2]}\n\n            4 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 4\n               :priority 1\n               :predecessors [3]}\n\n            5 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 4\n               :priority 1\n               :predecessors [3]}\n\n            ;; now some milestones\n            6 {:task-name \&quot;Toasts ready\&quot;\n               :is-milestone \&quot;srerzer\&quot;\n               :predecessors [3]\n               }\n\n            })&quot; &quot;(filter (comp :is-milestone val) tasks )&quot; &quot;(merge {:a 1} [:a 2])&quot; &quot;(seq [])&quot; &quot;(tasks-w-no-predecessors tasks)&quot; &quot;(vals (tasks-w-no-predecessors tasks))&quot; &quot;(keys (tasks-w-no-predecessors tasks))&quot; &quot;(vec (keys (tasks-w-no-predecessors tasks)))&quot; &quot;(tasks-w-no-field tasks :resource-id )&quot; &quot;(tasks-w-no-field tasks :predecessors )&quot; &quot;(errors-on-tasks tasks)&quot; &quot;(errors-on-tasks tasks [:duration ])&quot; &quot;(seq [a])&quot; &quot;(seq [:a])&quot; &quot;(clojure.pprint/pprint (errors-on-tasks tasks [:duration ]))&quot; &quot;(every? nil? {:reordering-errors {}, :tasks-w-no-resources-errors [], :tasks-cycles [], :milestones-w-no-predecessors []})&quot; &quot;(every? (comp nil? seq) {:reordering-errors {}, :tasks-w-no-resources-errors [], :tasks-cycles [], :milestones-w-no-predecessors []})&quot; &quot;(every? (comp nil? seq) (vals {:reordering-errors {}, :tasks-w-no-resources-errors [], :tasks-cycles [], :milestones-w-no-predecessors []}))&quot; &quot;(def tasks {1 {:task-name \&quot;Bring bread\&quot;\n               :resource-id \&quot;mehdi\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            2 {:task-name \&quot;Bring butter\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            3 {:task-name \&quot;Put butter on bread\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 3\n               :priority 1\n               :predecessors [1 2]}\n\n            4 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 4\n               :priority 1\n               :predecessors [3]}\n\n            5 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 4\n               :priority 1\n               }\n\n            ;; now some milestones\n            6 {:task-name \&quot;Toasts ready\&quot;\n               :is-milestone \&quot;srerzer\&quot;\n               :predecessors []\n               }\n\n            })&quot; &quot;(schedule! tasks [:duration])&quot; &quot;(into {:a 1} '([:a 2 ] [:a 3]))&quot; &quot;(def tasks {1 {:task-name \&quot;Bring bread\&quot;\n               :resource-id \&quot;mehdi\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            2 {:task-name \&quot;Bring butter\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 5\n               :priority 1\n               :predecessors []}\n\n            3 {:task-name \&quot;Put butter on bread\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 3\n               :priority 1\n               :predecessors [1 2]}\n\n            4 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;rafik\&quot;\n               :duration 4\n               :priority 1\n               :predecessors [3]}\n\n            5 {:task-name \&quot;Eat toast\&quot;\n               :resource-id \&quot;salma\&quot;\n               :duration 4\n               :priority 1\n               :predecessors [3]}\n\n            ;; now some milestones\n            6 {:task-name \&quot;Toasts ready\&quot;\n               :is-milestone true\n               :predecessors [3]\n               }\n\n            })&quot; &quot;(run-scheduler! (prepare-tasks tasks) [:duration])&quot; &quot;(tasks-w-no-field tasks :resource-id)&quot; &quot;(into {} (tasks-w-no-field tasks :resource-id))&quot; &quot;(seq nil)&quot; &quot;(nil? nil)&quot; &quot;(map (comp nil? seq field :is-milestone val) tasks)&quot; &quot;(map (comp nil? seq  :is-milestone val) tasks)&quot; &quot;(map (comp (not   :is-milestone val)) tasks)&quot; &quot;(filter (comp (not   :is-milestone val)) tasks)&quot; &quot;(filter (comp not   :is-milestone val) tasks)&quot; &quot;(tasks-w-no-field tasks :is-milestone)&quot; &quot;(errors-on-tasks tasks [:duration])&quot; &quot;(scheduler tasks [:duration])&quot; &quot;(schedule tasks [:duration])&quot; &quot;(def result ((schedule tasks [:duration]) :result))&quot; &quot;(prepare-tasks tasks)&quot; &quot;(def curated (prepare-tasks tasks))&quot; &quot;(total-task-duration tasks)&quot; &quot;(map :resource-id (vals curated))&quot; &quot;(into #{} (map :resource-id (vals curated)))&quot; &quot;\n(clojure.pprint/pprint (schedule tasks [:duration]))&quot; &quot;(errors-on-tasks {1 {:a 1 :predecessors  [4]}} [:a] )&quot; &quot;(errors-on-tasks {1 {:a 1 :predecessors  [2] } 2 {:a 2 :predecessors [] :is-milestone true}} [:a] )&quot; &quot;(errors-on-tasks {1 {:a 1 :predecessors  [2] } 2 {:a 2  :is-milestone true}} [:a] )&quot; &quot;(errors-on-tasks {1 {:a 1 :predecessors  [2] } 2 {:a 2 :predecessors [1]}} [:a] )&quot; &quot;(errors-on-tasks {1 {:a 1 :predecessors  [2] } 2 {:a 2 :predecessors [6] :is-milestone 2}} [:a] )&quot; &quot;(errors-on-tasks {1 {:a 1 :predecessors  [2] } 2 {:a 2 :predecessors [] :is-milestone 2}} [:a] )&quot; &quot;(tasks-w-no-field {1 {:a 1 :b 2}} :c)&quot; &quot;(tasks-w-no-field {1 {:a 1 :b 2 :c[]}} :c)&quot; &quot;(tasks-w-no-field {1 {:a 1 :b 2 }} :c)&quot; &quot;(comp not )&quot; &quot;((comp not :c val) {1 {:a 1 :b 2 :c 3}})&quot; &quot;((comp :c val) {1 {:a 1 :b 2 :c 3}})&quot; &quot;(:c {:a 1 :b 2 :c 3})&quot; &quot;(:c {:a 1 :b 2 :c []})&quot; &quot;(seq (:c {:a 1 :b 2 :c []}))&quot; &quot;(seq (:c {:a 1 :b 2 :c 4}))&quot; &quot;((comp seq) (:c {:a 1 :b 2 :c 4}))&quot; &quot;((comp seq vec ) (:c {:a 1 :b 2 :c 4}))&quot; &quot;(vec 4)&quot; &quot;((comp seq (partial into []) ) (:c {:a 1 :b 2 :c 4}))&quot; &quot;(tasks-w-no-field {1 {:a 1 :b 2 :c 3}} :c)&quot; &quot;(tasks-w-no-field {1 {:a 1 :b 2 :c []}} :c)&quot; &quot;((filter (comp not empty? :c val)) {1 {:a 1 :b 2 :c []}})&quot; &quot;(filter (comp not empty? :c val) {1 {:a 1 :b 2 :c []}})&quot; &quot;(filter (comp not empty? val)  {:a 1 :b 2 :c []})&quot; &quot;(filter (comp not empty?)  {:a 1 :b 2 :c []})&quot; &quot;(seq? 3)&quot; &quot;(seq? [])&quot; &quot;(empty? 3)&quot; &quot;(filter (comp not empty? (partial into []))  {:a 1 :b 2 :c []})&quot; &quot;(filter (comp not empty? (partial into []) val)  {:a 1 :b 2 :c []})&quot; &quot;(tasks-w-empty-predecessors {:a 1 :predecessors []} )&quot; &quot;(tasks-w-empty-predecessors {1 {:a 1 :predecessors []}} )&quot; &quot;(into [] [1 2] [3])&quot; &quot;(into [] [1 2] )&quot; &quot;(into (into [] [1 2] ) [ 2 3])&quot; &quot;(errors-on-tasks {1 {:predecessors [] :is-milestone true}})&quot; &quot;(errors-on-tasks {1 {:predecessors [] :is-milestone true :a 1}} [:a] )&quot; &quot;correct-tasks-schedule&quot; &quot;(correct-tasks-schedule 6)&quot; &quot;(get correct-tasks-schedule 6)&quot; &quot;(:result correct-tasks-schedule)&quot; &quot;((:result correct-tasks-schedule) 6)&quot;], :remote []}}</component>
</project>

